
## mem
### 先看整体内存使用
- free -h
- `top`（实时监控）按 m进入内存查看

### 看哪些进程吃内存（定位元凶）

### 1. 按内存排序列出进程

```
ps aux --sort=-%mem | head -20
```

- `--sort=-%mem`：按内存占比降序
- `head -20`：只看前 20 个

### 2. 只看内存相关列，更清爽

```
ps aux | awk '{print $4"\t"$2"\t"$11}' | sort -k1 -n -r | head -20
```

- 输出：`%MEM PID COMMAND`，按内存从高到低排。

### 3. 看某个进程的详细内存（如 PID=1234）

```
cat /proc/1234/status | grep -E "^Vm"
```

重点字段：

- `VmRSS`：物理内存占用（KB）
- `VmSize`：虚拟内存总大小

## 输出
curl -s -I --connect-timeout 10 http://flowdraft.cn 2>&1
### 一、核心原理：文件描述符的 “独立性”

在 Linux/Unix 系统中，**stdout（1）和 stderr（2）是两个完全独立的文件描述符**，它们的本质是指向不同 “文件” 的整数标识：

- 进程启动时，内核会默认打开 3 个文件描述符：0（stdin）、1（stdout）、2（stderr），默认都指向终端（/dev/tty）。
- 但它们是 “独立通道”—— 内核会分别管理这两个描述符的输出，就像两个并行的水管，水流（数据）互不干扰。

这种独立性是后续处理差异的根本原因：命令的 “正常输出” 走 1 号水管，“错误输出” 走 2 号水管，你可以对不同水管做不同的 “接管操作”。

### 二、后续处理的具体差异（附实操例子）

我用最常见的 “重定向” 和 “管道” 两个场景，对比两者的处理差异，你能直观感受到区别。

#### 场景 1：重定向（> 或 >>）

`>` 默认只重定向 stdout（1），不会影响 stderr（2），这是最容易踩坑的点。

bash

运行

```
# 例子1：只重定向stdout，stderr仍输出到终端
curl -s -I http://flowdraft.cn > output.txt  # 正常响应头写入output.txt，错误（如连接失败）直接显示在终端

# 例子2：想把所有输出写入文件，必须显式重定向stderr
curl -s -I http://flowdraft.cn > output.txt 2>&1  # stdout和stderr都写入output.txt
```

**差异本质**：`> filename` 是 `1> filename` 的简写，只操作 1 号描述符；2 号描述符若不手动指定，会保持默认指向终端。

#### 场景 2：管道（|）

管道 `|` 只会把前一个命令的 stdout（1）传递给后一个命令的 stdin（0），stderr（2）会直接绕过管道，输出到终端。

bash

运行

```
# 例子1：管道只接收stdout，stderr“逃逸”到终端
curl -s -I http://flowdraft.cn | grep "HTTP"  # 正常时grep能过滤HTTP状态码；若curl报错（如域名不存在），错误信息直接显示在终端，grep收不到

# 例子2：合并stdout和stderr后，管道才能处理错误信息
curl -s -I http://flowdraft.cn 2>&1 | grep -E "HTTP|error"  # 既能过滤正常的HTTP信息，也能过滤错误信息（如"Could not resolve host"）
```

**差异本质**：管道的设计逻辑是 “传递正常输出”，错误输出被视为 “需要用户立即看到的异常”，默认不参与管道流转。