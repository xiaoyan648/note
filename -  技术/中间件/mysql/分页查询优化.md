### 过大分页导致性能下降的原因

- **大量数据扫描**：常见分页方式如 `OFFSET - FETCH` 或 `LIMIT` 结合 `OFFSET` ，当偏移量（`OFFSET` 值）很大时，数据库需先扫描并跳过前面大量记录，才能定位到要返回的页数据。比如要查询第 1000 页（每页 10 条记录），`OFFSET` 值就是 9990，数据库要跳过这 9990 条记录，即便最终仅返回 10 条记录，也得遍历大量数据，数据量越大，扫描成本越高，消耗大量 CPU 和 I/O 资源 ，导致响应时间显著增加。
- **索引失效风险**：为跳过指定偏移量记录，数据库可能无法有效利用索引。尤其在复杂查询或数据分布不均时，即便有索引，也可能因偏移量过大，无法按预期利用索引快速定位数据，不得不进行全表扫描或大范围索引扫描，使查询性能大打折扣。
- **内存资源占用**：扫描大量记录过程中，数据库需将相关数据加载到内存处理，若数据量超出内存承载能力，会频繁读写磁盘交换数据，产生大量磁盘 I/O 操作，进一步降低查询性能；且在高并发场景下，大量内存被占用还可能引发资源竞争，影响其他查询执行 。
- **排序成本增加**：若分页查询涉及排序操作，数据量增大时，排序开销会剧增。如对大偏移量数据分页且需排序，数据库要对大量数据排序后再定位到指定页，排序算法复杂度随数据量上升，消耗更多 CPU 资源，使查询响应变慢。

### 解决办法

- **优化索引**：
    - **创建合适索引**：对常用于分页排序或筛选的字段创建索引，如在 `ORDER BY` 子句涉及字段上建索引。若查询条件包含多个字段，考虑创建复合索引，注意字段顺序按查询条件重要性和选择性从高到低排列，提高索引命中率，减少数据扫描范围。
    - **覆盖索引**：确保索引包含查询所需所有字段，数据库无需回表获取数据，减少 I/O 操作。例如查询仅需特定几列数据，创建包含这些列的覆盖索引，让查询直接从索引获取结果，加快查询速度。
- **改进查询方式**：
    - **基于上一页最后一条记录分页**：避免使用大偏移量的 `OFFSET` ，记录上一页最后一条记录的某个唯一标识（如自增 ID ），下一页查询以该标识为条件，获取大于该标识的记录。如查询商品表，上一页最后商品 ID 是 100 ，下一页查询 `SELECT * FROM products WHERE id > 100 LIMIT 10` ，减少数据库扫描数据量。
    - **键值定位分页**：对于有序数据（如按时间戳、自增 ID 排序 ），先获取指定页的起始键值（如最小 ID ），再以此为条件查询。如按时间戳分页查询订单记录，先确定该页起始时间戳，再查大于等于此时间戳的订单，可有效减少扫描范围。
    - **减少复杂 JOIN 和子查询**：复杂 JOIN 操作和子查询会增加查询计算复杂度，尽量拆分为简单查询分步执行，在应用层合并结果；或对 JOIN 结果使用缓存（如 Redis ）或物化视图，减少重复计算。
- **数据分区与分片**：
    - **表分区**：按一定规则（如时间、地域等 ）将大表划分为多个分区，查询时数据库仅扫描相关分区。如按月份对订单表分区，查询特定月份订单时，仅需在对应分区查找，减少扫描范围。
    - **数据分片**：将数据分散存储在多个节点，通过合理分片键（如用户 ID、地区等 ），系统在多节点分担负载，降低单个节点数据处理压力，提高整体查询性能。
- **缓存策略**：使用缓存层（如 Redis ）存储常用分页查询结果，用户请求时先查缓存，命中则直接返回，避免重复查询数据库。可结合缓存失效策略（如设置过期时间、手动刷新 ）保证数据实时性。对于计算复杂且查询频繁的分页请求，还可使用物化视图，预先计算并存储结果，定时或按需更新，加快查询响应。