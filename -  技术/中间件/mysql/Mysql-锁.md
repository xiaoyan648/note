## 序言
锁的效果和事务级别、索引都息息相关，接下来我们会分析在**不同事务级别和索引命中情况下，锁的效果；同时给出实际业务开发时应该注意的点。**

⚠️ 下文讨论前提都是在 innoDB 引擎下

## 锁的分类
在正式进入分析前，我们现过一下锁类型，对数据库中的锁有个大致的了解；从不同的视角出发，锁可以被区分为很多类型。
### 乐观锁&悲观锁
乐观锁和悲观锁是一种逻辑上的概念，用来区分对临界区的不同保护方式。
乐观锁：乐观的认为并发问题概率较小，直到需要修改数据时，才检测数据是否已经被修改过；如果已经被修改则可以直接认为操作失败或不断重试（自旋锁）
悲观锁：悲观认为并发问题概率较大，初始时就会加锁保护临界资源


### 共享锁&排它锁
### 行锁&范围锁
### 意向锁

## 可重复读

### 锁是如何生效的？
先来看一个最常见的案例，看看锁在可重复性隔离级别下是如何生效的 ，案例中 id=1 的行 a=1

| 事务 1                         | 事务 2                            | 事务3                             |
| ---------------------------- | ------------------------------- | ------------------------------- |
| 开始事务                         |                                 |                                 |
|                              | 开始事务                            |                                 |
|                              | 等待 事务3 锁释放...                   | update T set a=a+1 where id = 1 |
|                              | update T set a=a+1 where id = 1 |                                 |
|                              | select * form T where id = 1    |                                 |
|                              | commit;                         |                                 |
| select * form T where id = 1 |                                 |                                 |
| commit;                      |                                 |                                 |

这个场景的执行流程如下：

1. 事务3 获取到id = 1 此行的行锁，执行 a=a+1，得到结果 a=2，释放锁;
2. 事务2 获取到id = 1 此行的行锁，执行 a=a+1，得到结果 a=3，释放锁；这里，你可能会奇怪，根据可重复读的规定，事务中的 a 的值在开始事务的时候就已经确定了，a 读到的值应该是1，a=a+1=2才对；但Mysql肯定不允许这样的结果产生，为了保证并发安全，update 中的读取一定会读到最新版本的数据。因为 update 会加上共享锁，所以保证其他的事务都已经提交，最新版本的数据不会是一个中间状态的数据。更新操作执行完成后，会更新该事务2的视图。
3. 事务2 查询id = 1 此行，视图已经更新， a=3;
4. 事务1 查询 id = 1 此行，视图与刚创建时数据状态一致， a=1;

**最终 事务1 a=1；事务2 a=3**。

**所以我们可用得出如下结论：**
1. 事务中会自动给 update 语句加上排他锁
2. 锁在事务 commit 后才会释放
3. 更新依据的数据是最新的，更新后视图数据会被更新；
4. 除非有更新操作更新视图数据，否则试图与刚创建的数据状态一致，即使有其他事务新数据commit也无不影响

### 锁的粒度

**上诉案例加上的锁为行锁，如果语句能命中唯一一条记录就会加上行锁，也就是能够使用上主键索引或唯一索引的情况；如果是普通索引或没有命中索引的情况都是范围锁**

行锁的逻辑比较清晰，我们接下来重点分析范围锁的情况；

**表锁**
表锁可以看作一个范围最大的锁，将整张表都锁起来。如果

间隙锁、next-key lock

间隙锁（Gap Lock）是Innodb在提交下为了解决幻读问题时引入的锁机制，（下面的所有案例没有特意强调都使用可重复读隔离级别）幻读的问题存在是因为新增或者更新操作，这时如果进行范围查询的时候（加锁查询），会出现不一致的问题，这时使用不同的行锁已经没有办法满足要求，需要对一定范围内的数据进行加锁，间隙锁就是解决这类问题的。在可重复读隔离级别下，数据库是通过行锁和间隙锁共同组成的（next-key lock），来实现的

加锁规则有以下特性：


- 加锁的基本单位是（next-key lock）,他是前开后闭原则
- select for update 、update、insert… 过程中访问的对象会增加锁
- 索引上的等值查询--给唯一索引加锁的时候且改行存在，next-key lock升级为行锁
- 索引上的等值查询--给唯一索引a加锁的时候且改行不存在，next-key lock 退化为间隙锁，范围为 小于 a的最大行-大于a的最小行之间
- 范围查询、普通索引查询都会产生gas lock

## 读已提交
我们仍然使用上文 可重复读部分 的案例，案例中 id=1 的行 a=1

| 事务 1                         | 事务 2                            | 事务3                             |
| ---------------------------- | ------------------------------- | ------------------------------- |
| 开始事务                         |                                 |                                 |
|                              | 开始事务                            |                                 |
|                              | 等待 事务3 锁释放...                   | update T set a=a+1 where id = 1 |
|                              | update T set a=a+1 where id = 1 |                                 |
|                              | select * form T where id = 1    |                                 |
|                              | commit;                         |                                 |
| select * form T where id = 1 |                                 |                                 |
| commit;                      |                                 |                                 |



## 锁的应用场景


**场景一：**租户可以生成自己某一年的业绩报表文件，第一次下载的时候会收费，后续下载不再收费。

程序中的逻辑如下：


1. 判断用户是否生成过报表
	1. 是：跳过计费逻辑
	2. 否：生成图片存储，计费
2. 更新状态为已生成报表
3. 返回报表文件

如果这时并发请求，可能会多次计费，我们的原则是可以少计费，不能多计费，所以一定要做并非控制。其实这个多次消费的问题可以用 计费幂等号解决。

如果上层业务也要控制，因为这个场景并发量少，我们首先想到乐观锁：

update T set hasGenerate=true where Id = 1 and hasGenerate=false

这个hasGenerate=false其实就类似我们的版本好，如果更新失败原因是未找到更新数据，就可以认为是已经生成过报表，直接返回报表文件。这样也是业务无损的，因为并发访问的所有请求都可以拿到这个报表。

**场景二：唯一字段，比如 用户名**

在MySQL的InnoDB引擎中解决这类问题至少有4种思路：

加唯一索引：有两种方案，一是新建表，而是改造表，目的都是能添加上唯一索引，由唯一索引来保证插入数据的唯一性，其中改造表方案比较优雅；

锁表：采用显式锁表和解锁表的语句LOCK TABLES和UNLOCK TABLES来保证并发重复数据插入的顺序性，从而保证插入数据的唯一性；

先检查再插入：主要利用MVCC + Nextkey锁来保证检查和插入加锁的关联来保证插入数据的唯一性；？

采用insert ... select … 语句：利用insert ... select …原子执行的特点，再加上where子句实现了一种比较优雅的解决方案。？

后面三种不太靠谱，23锁粒度大，4不知道能不能用

通过中间件

如etcd，因为该方法只是为了解决高并发的情况，所以锁的时间可以设置很短--缺点需要引入分布式中间件，优点性能不错，一劳永逸

业务代码

通过读未提交去解决冲突，不用加锁

**场景二：购物场景**

业务有损

这个时候就不能使用乐观锁了，因为这是业务有损的操作，一旦并发冲突导致更新库存失败，就会导致用户购买报错，用户可能就不在想买这个物品了，用户体验会很差，并发量越大，越多人报错，这是不能节省的。所以需要使用悲观锁，保证每个人都可以购买成功。

**场景三：秒杀场景**

使用lock-free的思路进行优化，保护系统，减少资源开销，比如：redis evel lua脚本方案，kafka 异步消息处理等等。

**场景三：网关中间件**

比如 nginx，几乎所有的请求流量都打到了这个中间件，如果存在并发问题，它会通过 cas loop的方式解决，每个请求通过不断的轮训来尝试进入临界区，去掉了上下文切换的开销，是一种 look-free的实现思路。如果不是非常大的并发量，一般不会使用，会导致cpu空转浪费资源。

## Reference

[https://www.jianshu.com/p/32904ee07e56](https://www.jianshu.com/p/32904ee07e56)

[https://blog.er1c.dev/post/mysql/lock_analysis/](https://blog.er1c.dev/post/mysql/lock_analysis/)

[https://time.geekbang.org/column/article/75173](https://time.geekbang.org/column/article/75173)

[https://time.geekbang.org/column/article/75659](https://time.geekbang.org/column/article/75659)

[https://time.geekbang.org/column/article/78427](https://time.geekbang.org/column/article/78427)
