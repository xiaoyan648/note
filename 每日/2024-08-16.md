- [x] DevOps k8s看完
- [ ] DevOps 镜像优化 实验+笔记
	- 镜像大小压缩，一是通过减少基础镜像大小，比如使用 xx-alpine; 而是通过多阶段构建，比如先在外部构建可执行文件，dockerfile只copy加执行；或使用dockerfile自带的多阶段部署
	1.不加[]代表用 /bin/sh 执行 /opt/app/example ，由于 scratch 是空镜像，所以会报错：exec: "/bin/sh": stat /bin/sh: no such file or directory: unknown.（加[]代表为 ENTRYPOINT 提供参数） 2.没注意看Dockerfile，第二个回答稍微有点问题，编译是成功的，不过产生的二进制文件需要动态链接glibc 库，而程序运行镜像 alpine没有glibc ，所以因为无法找到glibc 库而启动报错
	- 镜像构建速度：通过镜像layler缓存，可以把变化频率、场景不同的部分放到不同layler，来实现复用，比如先go mod download，再go build，这样依赖不变只是代码变化则不同重新拉取依赖
- [ ] 4.30 - 6. 开始梳理配置
- [ ] 回家：锁整理笔记实验
- [ ] 回家：GoCahe 编译笔记 https://www.cnblogs.com/liuscraft/p/18061863 在云端构建时需要注意使用
	Go 编译缓存是 Go 语言编译过程中的一种优化机制，旨在提高编译效率和性能。通过缓存编译过程中的中间结果，可以避免重复计算和编译相同的代码块，从而显著减少编译时间。

	在 Go 的编译过程中，缓存机制主要体现在以下几个方面：

1. **增量编译**：Go 的 `go build` 命令默认启用了缓存功能，使得在修改文件后重新编译时能够快速命中缓存，从而大幅缩短编译时间。例如，在一个大程序的测试中，全新编译耗时 107 秒，而仅需重新编译修改过的部分则只需 22 秒。
    
2. **依赖管理**：使用 `go mod download` 命令构建的缓存层包含了所有依赖项，如果 go.mod 或 go.sum 文件没有变化，则可以直接使用该缓存，避免了重复下载依赖项，加速了构建过程。
    
3. **缓存清理**：执行 `go clean -cache` 命令可以清除编译缓存，释放内存空间。这在长时间运行的项目中尤为重要，因为缓存会占用大量内存。
    
4. **缓存内容及计算方式**：Go 编译缓存会将影响当前编译结果的所有参数加入到计算哈希值的内容里，如工作目录（Work Dir）、Go 版本、编译的文件及其哈希值、import 文件及其哈希值等。
    
5. **工具支持**：一些第三方工具如 `go-fast` 提供了额外的优化手段来进一步提升编译速度。这些工具集包括 `go-fast-compile` 和 `go-fast-build`，专为优化 Go 项目编译速度而设计。
    
6. **缓存策略**：Go 编译器采用了先进的自动优化技术，包括内联优化、死码消除和逃逸分析等，这些优化技术也间接提高了编译效率。
    

总之，Go 编译缓存通过多种机制和工具实现了编译过程的高效管理和优化，显著提升了开发者的编译体验和项目的构建速度。
- [ ] Trace（明日学习）
