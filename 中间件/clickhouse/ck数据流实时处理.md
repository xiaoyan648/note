
## 优点

为了高效的使用CPU，数据不仅仅按列存储，同时还按向量进行处理；

数据压缩空间大，减少IO；处理单查询高吞吐量每台服务器每秒最多数十亿行；

索引非B树结构，不需要满足最左原则；只要过滤条件在索引列中包含即可；即使在使用的数据不在索引中，由于各种并行处理机制ClickHouse全表扫描的速度也很快；

写入速度非常快，50-200M/s，对于大量的数据更新非常适用。

## 缺点

不持事务，不支持真正的删除/更新；

不支持高并发，官方建议qps为100，可以通过修改配置文件增加连接数，但是在服务器足够好的情况下；

不支持二级索引

有限的SQL支持，join实现与众不同

不支持窗口功能

元数据管理需要人工干预维护

SQL满足日常使用80%以上的语法，join写法比较特殊；最新版已支持类似SQL的join，但性能不好；

尽量做1000条以上批量的写入，避免逐行insert或小批量的insert，update，delete操作，因为ClickHouse底层会不断的做异步的数据合并，会影响查询性能，这个在做实时数据写入的时候要尽量避开；

ClickHouse快是因为采用了并行处理机制，即使一个查询，也会用服务器一半的CPU去执行，所以ClickHouse不能支持高并发的使用场景，默认单查询使用CPU核数为服务器核数的一半，安装时会自动识别服务器核数，可以通过配置文件修改该参数。

## 注意事项
1. **并行处理机制**：ClickHouse采用并行处理机制来提高查询性能，即使一个查询也会占用服务器一半的CPU资源。这种设计使得在高并发场景下，每个查询都会消耗大量资源，导致系统无法高效地处理多个并发请求。
    
2. **频繁单条写入的影响**：ClickHouse需要批量写入数据，频繁的单条写入会带来性能问题。这是因为每次插入操作都会产生一个新的part，如果开启多线程插入，每次插入至少处于不同的线程中，这会导致大量的part生成，从而增加系统的负担。
    
3. **merge线程池限制**：ClickHouse使用固定的merge线程池，默认为32个线程。如果插入过于频繁，merge线程池的压力过大，处理不了，就会出现“too many parts”的报错。这意味着在高并发情况下，合并数据的部分会变得非常繁忙，影响整体性能。
    
4. **并发数限制**：根据经验，在不触及ClickHouse IO瓶颈之前，影响写入速度与单批次insert插入的数量有关，高并发往往会带来负效果。官方建议的并发数不超过10个，这进一步说明了高并发对系统的负面影响。
    
5. **查询开销问题**：由于每个查询尽可能地利用最大的CPU资源，ClickHouse不适合高并发的场景。频繁的查询和插入操作会导致系统资源被过度占用，降低系统的可用性和稳定性。
- 要注意查询性能的优化，例如避免使用`select *` 这种写法，这样会浪费IO。
- 避免出现大量的小批量插入和更新操作，因为这会导致分区过多，影响性能。
- 在多表关联分析上，可以将右表构建成大宽表，使行尽量少，从而减少内存加载量
- ClickHouse的分布式表性能性价比不如物理表高，建表分区字段值不宜过多，防止数据导入过程磁盘压力过大
- 对于大数据量查询，使用主键索引能够精确找到所需的数据块，减少不必要的数据块扫描，从而提高查询效率

