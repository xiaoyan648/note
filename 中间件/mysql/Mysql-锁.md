锁的效果和事务级别、索引都息息相关，接下来我们会分析在**不同事务级别和索引命中情况下锁的效果，同时给出实际业务开发时应该注意的点。**

⚠️ 下文讨论前提都是在 innoDB 引擎下

## 可重复读

如下，是可重复性隔离级别下的案例 ，id=1 的行 a=1

| 事务 1                         | 事务 2                            | 事务3                             |
| ---------------------------- | ------------------------------- | ------------------------------- |
| 开始事务                         |                                 |                                 |
|                              | 开始事务                            |                                 |
|                              |                                 | update T set a=a+1 where id = 1 |
|                              | update T set a=a+1 where id = 1 |                                 |
|                              | select * form T where id = 1    |                                 |
| select * form T where id = 1 |                                 |                                 |
| commit;                      | commit;                         |                                 |

这个场景的执行流程如下：


1. 事务3 获取到id = 1 此行的行锁，执行 a=a+1，得到结果 a=2，释放锁;
2. 事务2 获取到id = 1 此行的行锁，执行 a=a+1，得到结果 a=3，释放锁；这里，你可能会奇怪，根据可重复读的规定，事务中的 a 的值在开始事务的时候就已经确定了，a 读到的值应该是1，a=a+1=2才对；但Mysql肯定不允许这样的结果产生，为了保证并发安全，update 中的读取一定会读到最新版本的数据。因为 update 会加上共享锁，所以保证其他的事务都已经提交，最新版本的数据不会是一个中间状态的数据。更新操作执行完成后，会更新该事务2的视图。
3. 事务2 查询id = 1 此行，视图已经更新， a=3;
4. 事务3 查询 id = 1 此行，视图与刚创建时数据状态一致， a=1;

**最终 事务1 a=1；事务2 a=3**

间隙锁、next-key lock

间隙锁（Gap Lock）是Innodb在提交下为了解决幻读问题时引入的锁机制，（下面的所有案例没有特意强调都使用可重复读隔离级别）幻读的问题存在是因为新增或者更新操作，这时如果进行范围查询的时候（加锁查询），会出现不一致的问题，这时使用不同的行锁已经没有办法满足要求，需要对一定范围内的数据进行加锁，间隙锁就是解决这类问题的。在可重复读隔离级别下，数据库是通过行锁和间隙锁共同组成的（next-key lock），来实现的

加锁规则有以下特性：


- 加锁的基本单位是（next-key lock）,他是前开后闭原则
- select for update 、update、insert… 过程中访问的对象会增加锁
- 索引上的等值查询--给唯一索引加锁的时候且改行存在，next-key lock升级为行锁
- 索引上的等值查询--给唯一索引a加锁的时候且改行不存在，next-key lock 退化为间隙锁，范围为 小于 a的最大行-大于a的最小行之间
- 范围查询、普通索引查询都会产生gas lock

## 读已提交



## 锁的应用场景

一定不要忘记，如果 where 条件带有索引，会加上行锁；没有的话，会加上表锁。

### 锁类型

- **共享锁**

mysql 在更新时会自动加上，可以保证对临界资源的查询（通过MVCC 保证不会读到中间状态），但是阻塞更新。


- **互斥锁（写锁）**

执行`select for update`  ，加上写锁，可以阻塞对临界资源的 `select for update`  请求和写请求


- **乐观锁**

乐观的认为不会出现并发问题，一旦出现并发通过快速失败解决问题。

mysql中的实现是借助读锁+版本号


- **自旋锁**

通过 cas loop 达到悲观锁的效果，是基于cpu的锁

### 场景分析


**场景一：**租户可以生成自己某一年的业绩报表文件，第一次下载的时候会收费，后续下载不再收费。

程序中的逻辑如下：


1. 判断用户是否生成过报表
	1. 是：跳过计费逻辑
	2. 否：生成图片存储，计费
2. 更新状态为已生成报表
3. 返回报表文件

如果这时并发请求，可能会多次计费，我们的原则是可以少计费，不能多计费，所以一定要做并非控制。其实这个多次消费的问题可以用 计费幂等号解决。

如果上层业务也要控制，因为这个场景并发量少，我们首先想到乐观锁：

update T set hasGenerate=true where Id = 1 and hasGenerate=false

这个hasGenerate=false其实就类似我们的版本好，如果更新失败原因是未找到更新数据，就可以认为是已经生成过报表，直接返回报表文件。这样也是业务无损的，因为并发访问的所有请求都可以拿到这个报表。

**场景二：唯一字段，比如 用户名**

在MySQL的InnoDB引擎中解决这类问题至少有4种思路：

加唯一索引：有两种方案，一是新建表，而是改造表，目的都是能添加上唯一索引，由唯一索引来保证插入数据的唯一性，其中改造表方案比较优雅；

锁表：采用显式锁表和解锁表的语句LOCK TABLES和UNLOCK TABLES来保证并发重复数据插入的顺序性，从而保证插入数据的唯一性；

先检查再插入：主要利用MVCC + Nextkey锁来保证检查和插入加锁的关联来保证插入数据的唯一性；？

采用insert ... select … 语句：利用insert ... select …原子执行的特点，再加上where子句实现了一种比较优雅的解决方案。？

后面三种不太靠谱，23锁粒度大，4不知道能不能用

通过中间件

如etcd，因为该方法只是为了解决高并发的情况，所以锁的时间可以设置很短--缺点需要引入分布式中间件，优点性能不错，一劳永逸

业务代码

通过读未提交去解决冲突，不用加锁

**场景二：购物场景**

业务有损

这个时候就不能使用乐观锁了，因为这是业务有损的操作，一旦并发冲突导致更新库存失败，就会导致用户购买报错，用户可能就不在想买这个物品了，用户体验会很差，并发量越大，越多人报错，这是不能节省的。所以需要使用悲观锁，保证每个人都可以购买成功。

**场景三：秒杀场景**

使用lock-free的思路进行优化，保护系统，减少资源开销，比如：redis evel lua脚本方案，kafka 异步消息处理等等。

**场景三：网关中间件**

比如 nginx，几乎所有的请求流量都打到了这个中间件，如果存在并发问题，它会通过 cas loop的方式解决，每个请求通过不断的轮训来尝试进入临界区，去掉了上下文切换的开销，是一种 look-free的实现思路。如果不是非常大的并发量，一般不会使用，会导致cpu空转浪费资源。

## Reference

[https://www.jianshu.com/p/32904ee07e56](https://www.jianshu.com/p/32904ee07e56)

[https://blog.er1c.dev/post/mysql/lock_analysis/](https://blog.er1c.dev/post/mysql/lock_analysis/)

[https://time.geekbang.org/column/article/75173](https://time.geekbang.org/column/article/75173)

[https://time.geekbang.org/column/article/75659](https://time.geekbang.org/column/article/75659)

[https://time.geekbang.org/column/article/78427](https://time.geekbang.org/column/article/78427)
